## 최단 경로 알고리즘

- 최단 경로 정의
  - 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점 까지의 최단 경로
  - 다익스트라(dijkstra) 알고리즘
    - 음의 가중치 허용 X
  - 벨만-포드(Bellman-Ford) 알고리즘
    - 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬(Floyd-Warshall) 알고리즘

### 다익스트라 알고리즘

- 시작 정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘

- 시작 정점에서의 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식

- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사

  ```java
  // s 시작 정점 // A 인접 행렬 // D 시작정점에서의 거리
  // V 정점 집합 // U 선택된 정점 집합
  Dijkstra(s, A, D)
      U = {s};
  	for 모든 정점 v
          D[v] = A[s][v];
  	while U != V
          D[w]가 최소인 정점 w in V-U 를 선택
          U = U + {w}
  		for w에 인접한 모든 미방문 정점 v
              D[v] = min(D[v], D[w] + A[w][v])
  ```

  ```java
  int[] distance = new int[V]; // 출발지에서 자신으로 오는 최소 비용
  		boolean[] isVisited = new boolean[V]; // 최소 비용 확정 여부
  
  		Arrays.fill(distance, Integer.MAX_VALUE);
  		distance[start] = 0; // 시작점 0으로
  
  		for (int i = 0; i < V; i++) {
  			// 단계1 최소 비용이 확정되지 않은 정점 중 최소 비용 정점 선택
  			int min = Integer.MAX_VALUE;
  			int current = 0;
  			for (int j = 0; j < V; j++) {
  				if (!isVisited[j] && min > distance[j]) {
  					current = j;
  					min = distance[j];
  				}
  			}
  			isVisited[current] = true;
  			// 단계2: 선택된 정점을 경유지로 하여 아직 최소 비용이 확정되지 않은 다른 정점의 최소비용을 고려
  
  			for (int j = 0; j < V; j++) {
  				if (!isVisited[j] && adjMatrix[current][j] != 0
  						&& distance[j] > distance[current] + adjMatrix[current][j]) {
  					distance[j] = distance[current] + adjMatrix[current][j];
  				}
  			}
  
  		}
  ```

   

## 문자열 패턴 매칭

- 패턴 매칭에 사용되는 알고리즘
  - 고지식한 패턴 검색 알고리즘
  - 라빈-카프 알고리즘
  - 보이어-무어 알고리즘
  - KMP 알고리즘
- 고지식한 패턴 검색 알고리즘
  - 최악의 경우 O(MN)
    - M은 검색할 문자열, N은 전체 문자열

- 라빈-카프 알고리즘
  - 문자열 검색을 위해 해시 값 함수를 이용
  - 패턴 내의 문자들을 일일이 비교하는 대신에 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만을 비교
  - 최악의 시간 복잡도 O(MN)이지만 평균적으로는 선형에 가까운 빠른 속도르 가지는 알고리즘
  - 처음 해시 값을 구할때는 찾고자 하는 문자열에서 패턴 길이 만틈 읽어서 구한다.
  - 문자열의 길이가 커지면 길이를 줄여주기 위해 mod 연산을 취해준다.
    - 따라서 해시 값이 일치하더라도 실제 패턴이 일치하지 않을 수 있기 때문에 해시 값이 일치하면 문자열 일치를 검사해야한다. (해시 충돌)
- 보이어 무어 알고리즘
  - 오른쪽에서 왼쪽으로 비교
  - 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이 만큼이 된다.
  - 최악 O(MN)이지만 최선 O(N/M)이며 평균적으로는 가장 빠른 속도를 가지는 알고리즘
  - 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하는 경우
    - 패턴에서 일치하는 문자의 위치만큼 점프
  - skip 배열 만들기
    - skip[ch] : 본문 ch 문자에서 패턴 불일치가 발생했을 때 본문 포인터의 skip 횟수
    - 패턴에 포함되지 않은 문자들은 본문 포인터가 패턴의 길이 만큼 skip 해야하므로 패턴의 길이가 skip 배열의 값이 됨
    - 패턴 문자들의 skip 배열 값(패턴 마지막 문자는 제외한다)
      - (패턴의 문자열 길이 - 1) - 각패턴의 문자의 인덱스

### KMP 알고리즘

- Knuth-Morris-Pratt 알고리즘
- 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 패턴을 전처리하여 부분일치 테이블 배열 pi[k]을 구해서 잘못된 시작을 최소화함
  - pi[k]: 처음부터 k인덱스까지를 끝으로 하는 문자열에서 일치하는 접두사와 접미사가 일치하는 최대길이
- 시간복잡도 O(M+N)
- 즉 실패한 부분만큼만 shift 해서 다시 비교 시작
- 