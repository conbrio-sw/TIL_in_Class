### 스택활용 - 계산기

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.
- 문자열 수식 계산의 일반적 방법
  - 중위 표기법의 수식을 후위 표기법으로 변경한다. (스택이용)
    - 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.
    - 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다.
    - 괄호를 제거한다.
  - 후위 표기법의 수식을 스택을 이용하여 계산한다.
    - 피연산자를 만나면 스택에 push 한다.
    - 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push 한다.
    - 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.

### 스택활용 - 브라우저

- 표준 웹 브라우저는 방문한 페이지들 내에서 이전, 이후 페이지를 방문하는 기능이 있다.
- 기본 페이지는 다음과 같다고 가정
  - `http://www.saafy,com`
- V(isit) : url로 방문
- B(ack) : 뒤로
- F(orward) : 앞으로

### 큐(Queue)

- 큐의 특성
  - 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
    - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
  - 선입선출구조(FIFO: First In First Out)
    - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

### 큐의 구조 및 기본 연산

- 큐의 선입선출구조
  - 머리 Front (마지막으로 삭제된 원소)
  - 꼬리 Rear (저장된 원소 중 마지막 원소)
- 큐의 기본 연산
  - 삽입: enQueue
  - 삭제: deQueue

### Queue API

- java.util.Queue
  - 큐에 필요한 연산을 선언해 놓은 인터페이스
  - LinkedList 클래스를 Queue 인터페이스의 구현체로 많이 사용

- 주요메서드
  - offer()
    - 삽입
  - poll()
    - 삭제
  - isEmpty()
  - size()

### 큐 활용 - 버퍼

- 버퍼
  - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
  - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
  - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다.

### 큐 활용 - 마이쮸

### 리스트

- 리스트
  - 순서를 가진 데이터의 집합을 가리키는 추상자료형(abstract data type)
  - 동일한 데이터를 가지고 있어도 상관 없다
  - 구현 방법에 따라 크게 두 가지로 나누니다.
    - 순차 리스트 : 배열을 기반으로 구현된 리스트
    - 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트

### 순차 리스트

- 구현방법
  - 1차원 배열에 항목들을 순서대로 저장한다.
  - 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열에 저장할 수도 있다.
  - 일부 메모리 공간 삭제가 불가능 (삭제된 것처럼 표현은 가능)
- 데이터 접근
  - 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있다.
- 삽입 연산
  - 삽입 위치 다음의 항목들을 뒤로 이동해야한다.
- 삭제 연산
  - 삭제 위치 다음의 항목들을 앞으로 이동해야한다.
- 문제점
  - 단순 배열을 이용한 순차리스트를 구현해 사용하는 경우, 자료의 삽입/삭젝 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다.
  - 원소의 개수가 많고 삽입, 삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가한다.
  - 배열의 크기가 정해져 있는 경우, 실제로 사용될 메모리보다 크게 할당하여 메모리의 낭비를 초래할 수도 있고 반대로 할당된 메모리보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업을 해야하는 경우가 발생할 수도 있다.

### 연결 리스트의 기본 구조

- 특성
  - 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 각 원소를 연결하여 하나의 전체적인 자료구조를 이룬다.
  - 링크를 통해 원소에 접근하므로, 순차리스트에서처럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
  - 자료 구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능하다.

- 노드
  - 연결 리스트에서 하나의 원소를 표현하는 building block
  - 구성요소
    - 데이터 필드
      - 원소의 값을 저장
      - 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함
    - 링크 필드
      - 다음 노드의 참조 값을 저장
- 헤드
  - 연결 리스트의 첫 노드에 대한 참조값을 갖고 있음
- 종류
  - 단순 연결 리스트
  - 이중 연결 리스트
  - 원형 연결 리스트

### 단순 연결 리스트

- 연결 구조
  - 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
  - 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
  - 링크 필드가 Null인 노드가 연결 리스트의 가장 마지막 노드이다.
- 단순 연결리스트로 스택 자료구조를 구현해보자
  - head를 top이라고 생각해보자
  - push = 첫 번째 노드에 삽입
  - pop = 첫 번쨰 노드 삭제

### 이중 연결 리스트

































