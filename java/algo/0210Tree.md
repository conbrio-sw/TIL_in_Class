# 트리

### 트리

- 개념
  - 비선형 구조 (한 부모는 자식이 여러개, 자식은 오로지 한 개의 부모)
  - 원소들 간에 1 : n 관계를 가지는 자료구조
  - 원소들 간에 계층관계를 가지는 계층형 자료구조
  - 상위 원소에서 하위 원소로 내려가면서 확장되는 트리 모양의 구조
- 정의
  - 노드 - 트리의 원소
  - 한개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
    - 노드 중 최상위 노드를 루트라 한다.
    - 나머지 노드들은 n개의 분리 집합 T1, ...., TN으로 분리 될 수 있다.
  - 이들 T1, ... , TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 부 트리(subtree)라 한다.
  - 간선(edge) - 노드와 노드를 연결하는 선으로 부모 노드와 자식 노드를 연결
  - 루트 노드(root node) - 트리의 시작 노드인 최상위 노드
  - 형제 노드(sibling node) - 같은 부모 노드의 자식 노드들
  - 조상 노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - 서브 트리 - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - 자손 노드 - 서브 트리에 있는 하위 레벨의 노드들
  - 차수(degree)
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
    - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
    - 단말 노드(리프 노드) : 차수가 0인 노드 (자식 노드가 없는 노드)
  - 높이(level, depth)
    - 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨 (루트 노드의 높이 = 0)
    - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨

### 이진트리

- 차수가 2인 트리
  - 차수가 고정이 되면 구현이 배열로 표현이 훨씬 쉽다.
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
  - 왼쪽 자식 노드 (left child node)
  - 오른쪽 자식 노드 (right child node)
- 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
  - 자식의 갯수가 0, 1, 2 셋 중 하나
- 특성
  - 높이 i에서의 노드의 최대 갯수
    - 2^i
  - 높이 h인 이진 트리가 가질 수 있는 노드의 수
    - 최소 : (h+1)
    - 최대 : 2^(h+1) - 1개 
- 종류
  - 포화 이진 트리 (Full Binary Tree)
    - 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
    - 높이가 h일 때, 최대의 노드 개수인 (2^(h+1) - 1)의 노드를 가진 이진 트리
    - 루트를 1번으로 하여 (2^(h+1) - 1)까지 정해진 위치에 대한 노드 번호를 가짐
  - 완전 이진 트리 (Complete Binary Tree)
    - 높이가 h이고 노드 수가 n개일 때, 이진 트리의 노드 번호 1번 부터 n번 까지 빈 자리가 없는 이진 트리
  - 편향 이진 트리 (Skewed Binary Tree)
    - 높이 h에 대한 최소 개수(h+1)의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가지는 이진 트리
    - 왼쪽 편향 이진 트리, 오른쪽 편향 이진 트리
- 배열을 이용한 이진 트리의 표현
  - 이진 트리에 각 노드 번호를 위에서부터, 왼쪽으로부터 부여
  - 루트의 번호를 1로 함
  - 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n부터 2^(n+1) - 1 까지 번호를 차례로 부여
  - 노드 번호의 성질
    - 노드 번호가 i인 노드의 부모 노드 번호?
      - i / 2
    - 노드 번호가 i인 노드의 자식 노드 번호?
      - 왼쪽 : 2 * i
      - 오른쪽 : 2 * i + 1
    - 레벨 n의 노드의 시작 번호는?
      - 2^n
  - 노드 번호를 배열의 인덱스로 사용
  - 높이가 h인 이진 트리를 위한 배열의 크기는?
    - 레벨 i의 최대 노드 수
      - 2 ^ i
    - 따라서 모든 노드의 수
      - 2 ^ (h+1) - 1
    - 배열의 크기는 2^(h+1)
      - 루트 노드의 번호가 1이기 때문에...!
  - 단점
    - 편향 이진 트리의 경우에 사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생
    - 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경 어려워 비효율적

#### 완전 탐색

- 비선형 구조인 트리, 그래프의 각 노드(정점)를 중복되지 않게 전부 방문하는 것을 말하는데, 비선형구조는 선형 구조에서와 같이 선후 연결 관계를 알 수 없다. 
  - 특별한 방법이 필요하다
- 너비 우선 탐색 (BFS)
- 깊이 우선 탐색 (DFS)

### 트리 탐색 - BFS

- 너비 우선 탐색 (Breadth First Search)
- 너비 우선 탐색은 루트 노드의 자식 노드들을 먼저 모두 차례로 방문한 후에, 방문했던 자식 노드들을 기준으로 하여 다시 해당 노드의 자식 노드들을 차례로 방문하는 방식
- 인전합 노드들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야하므로, 선입선출 형태의 자료구조인 큐를 활용함

```java
BFS()
	큐 생성
	루트 v를 큐에 삽입 (enqueue)
	while(큐가 비어있지 않으면){
		t <- 큐의 첫 번째 원소 반환 (dequeue)
		t 방문
		for (t와 연결된 모든 간선에 대해){
			u <- t의 자식노드
			u를 큐에 삽입 (enqueue)
		}
	}
end BFS()
```



### 트리 탐색 - DFS

- 재귀호출을 사용한다.
- 깊이 우선 탐색 (Depth First Search)
- 루트 노드에서 출발하여 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 노드로 되돌와서 다른 방향의 노드로 탐색을 계속 반복하여 결국 모든 노드를 방문하는 순회 방법
- 가장 마지막에 만났던 갈림길의 노드로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 재귀적으로 구현하거나 후입선출 구조의 스택 사용해서 구현

```java
DFS(v)
    v 방문;
	for(v의 모든 자식노드 w){
        DFS(w);
    }
end DFS()
```

### 순회

- 트리의 노드들을 체계적으로 방문하는 것
- 3가지
  - 전위순회
    - preorder traversal VLR
    - 부모 노드 방문 후, 자식 노드를 좌우 순서로 방문한다.
  - 중위순회
    - inorder traversal LVR
    - 왼쪽 자식 노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.
  - 후위순회
    - postorder traversal LRV
    - 자식노드를 좌우 순서로 방문한 후, 부모노드로 방문한다.

### 수식 트리

- 수식을 표현하는 이진 트리
- 수식 이진 트리라고 부르기도 함
- 연산자는 루트노드이거나 가지 노드
- 피연산자는 모두 잎 노드

### 힙

- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료 구조
- 최대 힙(max heap)
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 > 자식 노드의 키 값
  - 루트 노드 : 키 값이 가장 큰 노드
- 최소 힙(min heap)
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 < 자식 노드의 키 값
  - 루트 노드 : 키 값이 가장 작은 노드
- 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
- 루트 노드의 원소를 삭제하여 반환한다.
- 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.
- 우선순위 큐 (priority Queue)
  - 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것이다.
    - 노드 하나의 추가/삭제의 시간 복잡도가 O(logN)이고 최대값/최소값을 O(1)에 구할 수 있다.
    - 완전 정렬보다 관리비용이 적다
  - 배열을 통해 트리 형태를 쉽게 구현할 수 있다.
    - 부모나 자식 노드를 O(1) 연산으로 쉽게 찾을 수 있다.
    - n 위치에 있는 노드의 자식은 2n과 2n+1 위치에 존재한다.
    - 완전 이진 트리의 특성에 의해 추가/삭제 위치는 자료의 시작과 끝 인덱스로 쉽게 판단할 수 있다.
  - 특성
    - 우선순위를 가진 항목들을 저장하는 큐
    - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.
  - java.util.PriorityQueue
    - Heap 자료 구조
    - 최대 Heap
    - 최소 Heap
  - java.util.PriorityQueue()
    - 원소들의 natural Ordering에 따라 Heap 유지
    - 원소들 스스로 타원소와 자신을 비교하는 기능을 갖고 있다고 생각
      - 따라서 반드시 모든 원소는 Comparable 인터페이스를 구현해야함
  - java.util.PriorityQueue(Comparator comparator)
    - 명시된 Comparator(비교 도우미)의 구현에 따라 원소들의 순서를 유지
    - 원소들이 Comparable 인터페이스를 구현안해도 된다.
- 힙의 활용
  - 힙 정렬은 힙 자료구조를 이용해서 이진 트리와 유사한 방법으로 수행된다.
  - 정렬을 위한 2단계
    - 하나의 값을 힙에 삽입한다(반복)
    - 힙에서 순차적(오름차순)으로 값을 하나씩 제거한다.
  - 시간복잡도
    - N개의 노드 삽입 연산 + N개의 노드 삭제 연산
    - 노드 하나의 삽입과 삭제 연산은 각각 O(logN)이다.
    - 따라서 전체 정렬은 O(NlogN)이다.

### Comparable/Comparator

- java.lang.Comparable<T>
  - int compareTo(T other)
    - 자신과 인자로 전달 받는 타 원소와 비교하여 정수 리턴
      - 음수 결과 : 타 원소가 크다
      - 0 결과 : 둘이 같다
      - 양수 결과 : 자신이 크다.
  - int compare(T o1, T o2)
    - 비교 대상의 두 원소가 아닌 별도의 도우미 역할
    - 두 원소(o1, o2) 비교하여 정수 리턴
      - 음수 결과 :o2 원소가 크다.
      - 0 결과 : 둘이 같다
      - 양수 결과 : o1원소가 크다.